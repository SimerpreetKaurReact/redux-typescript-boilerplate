# Redux

predictable state container for javascript apps
The patterns and tools provided by redux make it easier to understand when, where, why and how the state in your applicatuon is being updated, and how your application logic will behace when those changes occur
The global state of your application is stored as an object inside a single store
The only way to change the state is to dispatch an action, an object that describes what happened
To specify how the state tree is updated based on an action, you write pure reducers
Store holds the state
It allows accesss to the state via getState()
Allows state to be updated via dispatch(action)
registers listeners via subscibe(listener)
Middleware is the suggested way to extend redux functionality
Provides third party extension between dispatching an action, and the moment it reaches the reducer
use middeware for logging,crash reporting, performing async tasks

# Redux toolkit

redux toolkit works as a abstraction over redux, minmizing the boiler plate code

When redux should be used
-- you have large amounts of application state that are needed in many places in the app
-- the app state is updated frequently
-- the logic to update that state may be complex
-- the app has medium or large sized codebase, and might be worked on by many people
Redux toolkit take care of actiontypes with name of the slice and key of the reducers object
with redux toolkit, reducers will respond to action types generated by the same reduxSlice, so we have the concept of extra reducers
createAsyncThunk:RTK method for thunk functionality,takes 2 arguments, first being action name, 2nd callback function that creates the payload. this function dispatched lifecycle actions based on the promise. A promise is either rejected, fullfilled, or pending. we can listent to the action types with a reducer functions and perform the state transitions, these reducers can be added to extra reducers

# Immer

When using Immer, changes are made to a draft object, that records the changes and takes care of creating the necessary copies, without ever affecting the original object, ie following the immutable data
